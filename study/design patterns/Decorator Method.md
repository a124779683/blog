# 装饰者模式
---
在博客园看到一篇介绍装饰者模式非常好的一片文章，本文**摘取自该篇文章《[来杯咖啡-装饰者模式(Decorator)][ref]》**。感谢作者：**王晓亮-在路上**

>装饰者模式可以**动态地给一个对象增加其他职责**。就扩展对象功能来说，装饰者模式比生成子类更为灵活。
>
>上面提到的动态和静态的问题，所谓动态是说可以在系统运行时(RunTime)动态给对象增加其它职责而不需要修改代码或重新编译；所谓静态是说必须通过调整代码(DesignTime)才能给对象增加职责,而且系统还需要重新编译；从具体技术层面来说，**对象的组合和继承正好对应于前面的动态和静态**

## 类图 
![Decoration](http://a1.qpic.cn/psb?/V12r9fmQ4ALxpC/mX.xcEzTTYt53konjD9F5Q3JU8HdQsrvp4qe.UyHen4!/b/dKUAAAAAAAAA&bo=KgIWAQAAAAABBx8!&rf=viewer_4)  

* Component（被装饰对象基类）
定义对象的接口，可以给这些对象动态增加职责；

* ConcreteComponent（具体被装饰对象）
定义具体的对象，Decorator可以给它增加额外的职责；

* Decorator（装饰者抽象类）
维护一个指向Component实例的引用，并且定义了与Component一致的接口；

* ConcreteDecorator（具体装饰者）
具体的装饰对象，给内部持有的具体被装饰对象增加具体的职责；

## 优点：  
* 装饰者模式遵循了开闭（OCP）原则，保护原有代码的健壮性不受任何影响。  
* 遵循了DRY原则，解决了代码重复的问题。
* 通过组合而非继承的方式，实现了动态扩展对象的功能的能力。
* 有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。
* 充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。
* 装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。
* 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。

## 缺点
* 装饰链不能过长，否则会影响效率。
* 因为所有对象都是Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。
* 只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。

## 应用场景：

1. 想透明并且动态地给对象增加新的职责的时候。
2. 给对象增加的职责，在未来存在增加或减少可能。
3. 用继承扩展功能不太现实的情况下，应该考虑用组合的方式。

## 参考资料
1. [设计模式学习笔记-装饰模式][ref1]

[ref]:"http://www.cnblogs.com/justinw/articles/779356.html?page=1"
[ref1]:http://www.cnblogs.com/wangjq/archive/2012/07/03/2574755.html (装饰者模式)